<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>KAPI RUN</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">

  <link rel="manifest" href="appmanifest.json">
  <link rel="apple-touch-icon" sizes="128x128" href="icons/icon-128.png">
  <link rel="apple-touch-icon" sizes="256x256" href="icons/icon-256.png">
  <link rel="icon" type="image/png" href="icons/icon-256.png">

  <link rel="stylesheet" href="style.css">

  <style>
    html, body { height:100%; margin:0; background:#000; overflow:hidden; }

    /* $OKAPI badge */
    #score-display {
      position: fixed; top: 12px; left: 12px;
      background: rgba(0,0,0,.6); color: #fff;
      padding: 6px 12px; border-radius: 8px;
      font: 700 14px/1.4 system-ui, Arial;
      z-index: 99999; backdrop-filter: blur(2px);
      user-select: none; -webkit-user-select: none;
    }

    /* FULLSCREEN button */
    #kr-fullscreen {
      position: fixed; right: 12px; top: 12px; z-index: 99999;
      padding: 8px 12px; border: 0; border-radius: 10px;
      background: #10b981; color: #081c15; font-weight: 700; font-size: 13px;
      box-shadow: 0 4px 14px rgba(0,0,0,.15); cursor: pointer;
    }

    /* Debug test button (optional) */
    #kr-debug {
      position: fixed; right: 12px; bottom: 12px; z-index: 99999;
      padding: 10px 14px; border: 0; border-radius: 10px;
      background: #0a84ff; color: #fff; font-size: 14px; display: none;
    }

    /* Desktop fs ipucu (fs=1‚Äôle a√ßƒ±lan sayfada) */
    #fs-hint {
      position: fixed; inset: 0; display: none; place-items: center; z-index: 99998;
      background: rgba(0,0,0,.55); color: #fff; font: 600 16px/1.6 system-ui, Arial;
      text-align: center; padding: 24px;
    }

    /* üîÑ Rotate hint (MOBILE flow) */
    #rotate-hint {
      position: fixed; inset: 0; display: none; place-items: center; z-index: 99998;
      background: rgba(0,0,0,.8); color: #fff; text-align: center; padding: 28px;
      font: 700 18px/1.6 system-ui, Arial;
    }
    #rotate-hint small { display:block; opacity:.8; font-weight:600; margin-top:.5rem; }
  </style>

  <!-- üîπ HOOK & SCORE (main.js‚ÄôDEN √ñNCE) -->
  <script>
    // --- TG hash params ---
    const __params   = new URLSearchParams(location.hash.slice(1));
    const __user_id  = __params.get('u');
    const __chat_id  = __params.get('c');
    const __msg_id   = __params.get('m');
    const __token    = __params.get('t');

    // --- Score POST (global) ---
    async function submitScore(finalScore, username){
      try{
        if (!__user_id || !__chat_id || !__msg_id || !__token) {
          console.warn("[KAPI] Not in Telegram context; skipping score submit.");
          return false;
        }
        const res = await fetch('/api/score', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({
            user_id: Number(__user_id),
            chat_id: Number(__chat_id),
            message_id: Number(__msg_id),
            token: __token,
            score: Number(finalScore)||0,
            username: username || null
          })
        });
        const j = await res.json().catch(()=>({}));
        if (!res.ok || !j.ok){ console.error('[KAPI] Score submit failed:', j); return false; }
        console.log('[KAPI] Score submitted:', finalScore);
        return true;
      }catch(e){ console.error('[KAPI] Score submit error:', e); return false; }
    }
    window.submitScore = submitScore;
    window.KAPI_sendScore = submitScore;

    // --- $OKAPI badge (global) ---
    let __uiScore = 0;
    function updateScore(newScore){
      __uiScore = Number(newScore)||0;
      const box = document.getElementById('score-display');
      if (box) box.textContent = "$OKAPI: " + __uiScore;
    }
    window.updateScore = updateScore;

    // --- Auto score detect (Construct hook) ---
    let SCORE_KEY = null;
    window.KAPI_SET_SCORE_KEY = k => { SCORE_KEY = k; console.log('[KAPI] SCORE_KEY set:', k); };

    const CANDIDATE_KEYS = ['Score','Skor','Puan','Points','Point','Coin','Coins','OKAPI','Okapi'];
    let lastValues = {}; let lastPeak = 0; let inRun = false; let submitted = false; let idleTicks = 0; let lastShown = -1;

    (function hookC3Runtime(){
      function attachHook(){
        try{
          if (!self.C3_CreateRuntime) return false;
          if (self.C3_CreateRuntime.__wrapped) return true;

          const orig = self.C3_CreateRuntime;
          self.C3_CreateRuntime = function(cfg){
            const rt = orig(cfg);
            try{
              window.__c3rt = rt;

              setInterval(()=>{
                const gv = (rt && rt.globalVars) ? rt.globalVars : {};
                let num = NaN;

                if (SCORE_KEY && typeof gv[SCORE_KEY] !== 'undefined'){
                  num = Number(gv[SCORE_KEY]);
                } else {
                  for (const k of CANDIDATE_KEYS){
                    if (typeof gv[k] !== 'undefined'){
                      const v = Number(gv[k]);
                      if (!Number.isNaN(v)){ num = v; SCORE_KEY = k; break; }
                    }
                  }
                  if (Number.isNaN(num)){
                    let bestKey=null,bestDelta=0;
                    for (const [k,vRaw] of Object.entries(gv)){
                      const v = Number(vRaw); if (Number.isNaN(v)) continue;
                      const prev = lastValues[k];
                      const d = (typeof prev==='number') ? (v - prev) : 0;
                      if (d > bestDelta && d < 1e6){ bestDelta=d; bestKey=k; num=v; }
                    }
                    if (bestKey) SCORE_KEY=bestKey;
                  }
                }

                for (const [k,v] of Object.entries(gv)){
                  const n = Number(v); if (!Number.isNaN(n)) lastValues[k]=n;
                }

                if (!Number.isNaN(num) && num !== lastShown){
                  lastShown = num; updateScore(num);
                }

                if (!Number.isNaN(num) && num > 0){ inRun = true; lastPeak = Math.max(lastPeak, num); }

                let go=false;
                try{
                  const g = rt.globalVars;
                  go = !!(g && (g.GameOver===1 || g.GameOver===true || g.IsGameOver===1 || g.Game_Over===1 || g.dead===1 || g.Dead===1));
                }catch(_){}

                if (!Number.isNaN(num) && num === lastShown) idleTicks++; else idleTicks=0;

                if (go && inRun && !submitted){ submitted=true; submitScore(lastPeak); }
                if (idleTicks>=10 && inRun && !submitted){ submitted=true; submitScore(lastPeak); }

                if (submitted && (Number.isNaN(num) || num===0)){
                  lastValues={}; lastPeak=0; inRun=false; submitted=false; idleTicks=0; lastShown=-1;
                }
              }, 300);
            }catch(e){ console.warn('[KAPI] hook error', e); }
            return rt;
          };
          self.C3_CreateRuntime.__wrapped = true;
          return true;
        }catch(e){ return false; }
      }
      if (!attachHook()){
        let tries=0; const iv=setInterval(()=>{ tries++; if (attachHook()||tries>50) clearInterval(iv); }, 100);
      }
    })();

    // Helpers
    function isMobile(){ return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }
    function isTelegram(){ return !!(window.Telegram) || /Telegram/i.test(navigator.userAgent); }
    function isLandscape(){ return window.innerWidth > window.innerHeight; }

    // Fullscreen (generic)
    async function tryFullscreen(){
      const el = document.documentElement;
      const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
      if (req) {
        try { await req.call(el); document.getElementById('fs-hint').style.display='none'; }
        catch(e){ /* some clients need a user gesture later */ }
      }
    }
  </script>
</head>
<body>
  <div id="score-display">$OKAPI: 0</div>
  <button id="kr-fullscreen">FULLSCREEN</button>
  <button id="kr-debug">Test Skor (123)</button>

  <!-- Desktop fs ipucu -->
  <div id="fs-hint">Tap/click once to enter fullscreen</div>
  <!-- üîÑ Mobile rotate ipucu -->
  <div id="rotate-hint">
    Rotate your phone to landscape for fullscreen
    <small>(If it doesn't enter fullscreen automatically, tap once.)</small>
  </div>

  <!-- Game files -->
  <script src="scripts/supportcheck.js"></script>
  <script src="scripts/offlineclient.js" type="module"></script>
  <script src="scripts/main.js" type="module"></script>
  <script src="scripts/register-sw.js" type="module"></script>

  <!-- Telegram Games SDK -->
  <script src="https://telegram.org/js/games.js"></script>

  <script>
    const debugBtn = document.getElementById('kr-debug');
    const fsHint   = document.getElementById('fs-hint');
    const rotHint  = document.getElementById('rotate-hint');
    const fsBtn    = document.getElementById('kr-fullscreen');

    // Show debug button with ?debug=1
    (function showDebugIfRequested(){
      const inTelegram = !!(__user_id && __chat_id && __msg_id && __token);
      const debug = new URLSearchParams(location.search).get('debug') === '1';
      if (inTelegram && debug && debugBtn){
        debugBtn.style.display='block';
        debugBtn.onclick = async()=>{ const ok=await submitScore(123); alert(ok?'Skor g√∂nderildi ‚úÖ':'G√∂nderilemedi ‚ùå'); };
      }
    })();

    // Desktop flow: open new tab with fs=1; Mobile Telegram: show rotate hint then fullscreen on landscape
    function buildFsUrl(){
      const base = location.origin + location.pathname;
      const qs = new URLSearchParams(location.search);
      qs.set('fs','1');
      return base + '?' + qs.toString() + location.hash; // keep hash ‚Üí scoring works
    }

    function openFullscreenFlow(){
      if (isTelegram() && isMobile()){
        // 1) Gentle try now (often blocked), then show ROTATE overlay
        tryFullscreen();
        rotHint.style.display = 'grid';

        const onRotate = async () => {
          if (isLandscape()) {
            rotHint.style.display = 'none';
            window.removeEventListener('resize', onRotate);
            window.removeEventListener('orientationchange', onRotate);
            await tryFullscreen();
          }
        };
        window.addEventListener('resize', onRotate);
        window.addEventListener('orientationchange', onRotate);

        // fallback: first tap after the hint
        rotHint.addEventListener('pointerdown', async () => { await tryFullscreen(); }, { once:true });

      } else {
        // Desktop / non-Telegram: open new tab with fs=1 (shows fs-hint)
        const url = buildFsUrl();
        const win = window.open(url, '_blank', 'noopener');
        if (!win) location.href = url;
      }
    }
    fsBtn.addEventListener('click', openFullscreenFlow);

    // Desktop fs flow (fs=1 tab): show hint & try fullscreen at first interaction
    const wantFs = new URLSearchParams(location.search).get('fs') === '1';
    if (wantFs){
      fsHint.style.display='grid';
      tryFullscreen(); // immediate try
      window.addEventListener('pointerdown', async ()=>{ await tryFullscreen(); }, { once:true });
      document.addEventListener('fullscreenchange', ()=>{
        if (document.fullscreenElement) fsHint.style.display='none';
      });
    }

    // Telegram WebApp cosmetics
    if (window.Telegram && Telegram.WebApp) {
      try { Telegram.WebApp.expand(); Telegram.WebApp.ready(); } catch(_){}
    }
  </script>
</body>
</html>
